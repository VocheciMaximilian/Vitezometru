/******** 0.  ANTETE ȘI GLOBALE *****************************************/
#include <LiquidCrystal.h>
#include <ThreeWire.h>
#include <RtcDS1302.h>
#include <EEPROM.h>

#ifndef M_PI
#define M_PI 3.1415926535
#endif

/* --- COMANDA DE LA PC --- */
#define CMD_EXPORT_TRIPS_NOW_STR "EXPORT_TRIPS_NOW" // Comanda pe care o va trimite Python

/* ——— DEFINIȚII ADRESE EEPROM ——— */
#define EEPROM_ADDR_MAGIC_NUM    0  // 2 bytes pentru un număr magic de verificare
#define EEPROM_ADDR_WHEEL_DIAM   (EEPROM_ADDR_MAGIC_NUM + 2) // float (4 bytes)
#define EEPROM_ADDR_ODOMETER     (EEPROM_ADDR_WHEEL_DIAM + sizeof(float)) // float (4 bytes)
#define EEPROM_ADDR_TOTAL_RIDE_MS (EEPROM_ADDR_ODOMETER + sizeof(float)) // unsigned long (4 bytes)
#define EEPROM_ADDR_ACTIVE_TRIP_IDX (EEPROM_ADDR_TOTAL_RIDE_MS + sizeof(unsigned long)) // byte (1 byte)
#define EEPROM_ADDR_TRIPS_START  (EEPROM_ADDR_ACTIVE_TRIP_IDX + sizeof(byte)) // Începutul zonei pentru ture
#define EEPROM_MAGIC_VALUE       0xABBA // Un număr pentru a verifica dacă EEPROM a fost inițializat

/* ——— PINI  ——— */
const byte LCD_CONTRAST_PIN = 9;
const byte LCD_RS  = 3;
const byte LCD_EN  = 8;
const byte LCD_D4  = 4;
const byte LCD_D5  = 5;
const byte LCD_D6  = 6;
const byte LCD_D7  = 7;

const byte HALL_PIN   = 13; // Asigură-te că acesta corespunde PCINT5
const byte BUZZER_PIN = 2;

const byte BTN_UP   = A2;   // ↑ / „DA”
const byte BTN_MODE = A1;   // MOD
const byte BTN_DOWN = A0;   // ↓ / „NU”
const byte BTN_OK   = A3;   // OK / Confirm

/* ——— RTC Makuna DS1302 ——— */
#define DS1302_DAT 11
#define DS1302_CLK 10
#define DS1302_RST 12
ThreeWire      myWire(DS1302_DAT, DS1302_CLK, DS1302_RST);
RtcDS1302<ThreeWire> rtc(myWire);

/* ====== CODURI PENTRU MODUL LOCK ====== */
enum BtnCode : byte { CODE_DN = 0, CODE_MD = 1, CODE_UP = 2, CODE_OK = 3 };

/* ====== VARIABILE LOCK ====== */
byte  lockPin[4]   = {0,0,0,0};
byte  pinIndex     = 0;
byte  attemptsLeft = 3;
bool  lockArmed    = false;
bool  alarmActive  = false;
unsigned long lockArmedTime = 0; 
const unsigned long lockGracePeriodMillis = 2000;

/* ====== PAGINA GLOBALĂ (Normal Mode) ====== */
byte page = 0;

/* ——— LCD ——— */
LiquidCrystal lcd(LCD_RS, LCD_EN, LCD_D4, LCD_D5, LCD_D6, LCD_D7);

/* ——— STARE GENERALĂ ——— */
enum Mode { MODE_NORMAL, MODE_TRIP, MODE_LOCK };
Mode currentMode = MODE_NORMAL;

/* ——— DATE ROTAȚII ——— */
volatile unsigned long lastPulseMicros   = 0;
volatile unsigned long pulseCount        = 0;
volatile bool          newPulseDetected  = false; 

/* ——— UTILITARE ——— */
float wheelDiameterIn   = 26.0;          
float wheelCircum_mm    = wheelDiameterIn * 25.4 * M_PI;

unsigned long standbyTimeout    = 5UL * 60UL * 1000UL; 
unsigned long lastMovementMillis = 0;
unsigned long lastEepromSaveMillis = 0;
const unsigned long eepromSaveIntervalMoving = 30000UL; 
const unsigned long eepromSaveIntervalStopped = 5000UL; 

/* ——— STRUCTURĂ TURĂ ——— */
#define MAX_TRIPS 5 
struct Trip {
  float avgSpeed;
  float maxSpeed;
  float minSpeed; 
  float distance_km;
  unsigned long duration_s;
  RtcDateTime stamp;
  unsigned long tripStartTimeMillis; 
} trips[MAX_TRIPS];

byte  activeTripIndex = 0; 
bool  tripRunning     = false;

/* ——— ALTE VARIABILE ——— */
float instantSpeed   = 0;
float rpm            = 0;
float rollingSpeedBuffer[10]; 
byte  rollingIdx = 0;

/* ——— ODOMETRU GLOBAL ȘI TIMP TOTAL ——— */
float odometer_km = 0; 
unsigned long totalActiveRideMillis = 0; 
bool dataChangedSinceLastSave = false;

/*************************************************************************
   FUNCTIE UTILA:  printFloatFix()
**************************************************************************/
void printFloatFix(float val, byte width, byte prec) {
  char buf[12];                     
  dtostrf(val, width, prec, buf);   
  lcd.print(buf);
}

/*************************************************************************
   PROTOTIPURI
**************************************************************************/
void loadFromEEPROM();
void saveSettingsToEEPROM();
void saveOdometerDataToEEPROM();
void saveTripToEEPROM(byte tripIdx);
bool readButtons(bool&, bool&, bool&, bool&);
float calculateAverageSpeed(); 
void handleStandby();
void updateOdoAndTripData(); 
void drawNormalPages(byte);
void runSettingsMenu();
bool confirmStartTrip();
bool confirmStartLock();
void lockModeRunner(bool,bool,bool,bool,bool);
void tripModeRunner(bool,bool,bool,bool); 
void startStopTrip(bool);
void setWheelDiameter();
void setClockTime();
void setClockDate();
void factoryReset();
void exportTripsToSerial(bool triggeredByPC = false); // <<--- MODIFICAT: Adăugat parametru
unsigned long getTotalRideTimeDays();

/*************************************************************************
 * 1. setup()
*************************************************************************/
void setup() {
  Serial.begin(9600); 

  pinMode(LCD_CONTRAST_PIN, OUTPUT);
  analogWrite(LCD_CONTRAST_PIN, 120); 
  lcd.begin(16,2); lcd.clear();
  lcd.print(F("Vitezometru...")); 

  pinMode(BTN_UP  , INPUT_PULLUP);
  pinMode(BTN_DOWN, INPUT_PULLUP);
  pinMode(BTN_MODE, INPUT_PULLUP);
  pinMode(BTN_OK  , INPUT_PULLUP);

  pinMode(BUZZER_PIN, OUTPUT); digitalWrite(BUZZER_PIN, LOW);

  pinMode(HALL_PIN, INPUT_PULLUP);
  PCICR  |= (1 << PCIE0);    
  PCMSK0 |= (1 << PCINT5);  

  rtc.Begin();
  if (!rtc.IsDateTimeValid() || rtc.GetDateTime().Year() < 2023) {
      RtcDateTime compiledTime(__DATE__, __TIME__);
      rtc.SetDateTime(compiledTime);
      if (!rtc.GetIsWriteProtected()) {
          rtc.SetIsWriteProtected(true); 
      }
  }
  
  loadFromEEPROM(); 

  wheelCircum_mm = wheelDiameterIn * 25.4 * M_PI; 

  lastMovementMillis = millis();
  lastEepromSaveMillis = millis();
  delay(1500); 
  lcd.clear();
}

/*************************************************************************
 * 2.  ISR Hall
*************************************************************************/
ISR(PCINT0_vect) {
  if (!(PINB & (1 << PB5))) return; 

  unsigned long now = micros();
  unsigned long dT  = now - lastPulseMicros;
  
  if (dT < 10000) return; // Debounce/ignore very fast pulses

  lastPulseMicros   = now;
  pulseCount++;
  newPulseDetected = true; 
}

/*************************************************************************
 * 3.  readButtons()
*************************************************************************/
bool readButtons(bool &up, bool &down, bool &mode, bool &ok) {
  static unsigned long lastReadTime = 0;
  static byte lastButtonState = 0xFF; 
  const unsigned int DEBOUNCE_DELAY = 50; 

  up = false; down = false; mode = false; ok = false; 

  if (millis() - lastReadTime < DEBOUNCE_DELAY) {
    return false; 
  }
  lastReadTime = millis();

  byte currentButtonState = 0; 
  if (digitalRead(BTN_UP)   == LOW) currentButtonState |= 0b1000;
  if (digitalRead(BTN_DOWN) == LOW) currentButtonState |= 0b0100;
  if (digitalRead(BTN_MODE) == LOW) currentButtonState |= 0b0010;
  if (digitalRead(BTN_OK)   == LOW) currentButtonState |= 0b0001;

  byte pressedButtons = (currentButtonState & ~lastButtonState); 
  
  lastButtonState = currentButtonState; 

  if (pressedButtons > 0) { 
    if (pressedButtons & 0b1000) up = true;
    if (pressedButtons & 0b0100) down = true;
    if (pressedButtons & 0b0010) mode = true;
    if (pressedButtons & 0b0001) ok = true;
    return true; 
  }
  return false; 
}

/*************************************************************************
 * 4. calculateAverageSpeed() - viteza medie "rolling"
*************************************************************************/
float calculateAverageSpeed() {
  float sum = 0;
  byte count = 0;
  for (byte i=0; i<10; i++) {
    sum += rollingSpeedBuffer[i];
    if (rollingSpeedBuffer[i] > 0.01f || i < rollingIdx) { // Consider non-zero speeds or filled buffer parts
        count++;
    }
  }
  return (count > 0) ? (sum / count) : 0.0;
}

/*************************************************************************
 * 5. updateOdoAndTripData() - procesează pulsul detectat de ISR
*************************************************************************/
void updateOdoAndTripData() {
  static unsigned long localPulseCountCopy = 0;
  unsigned long currentPulseCountSnapshot;
  
  noInterrupts();
  currentPulseCountSnapshot = pulseCount;
  interrupts();

  if (currentPulseCountSnapshot == localPulseCountCopy) return; 

  unsigned long deltaPulses = currentPulseCountSnapshot - localPulseCountCopy;
  localPulseCountCopy = currentPulseCountSnapshot;

  float delta_km = (wheelCircum_mm * deltaPulses) / 1000000.0; 

  odometer_km += delta_km; 
  dataChangedSinceLastSave = true;

  if (tripRunning && activeTripIndex < MAX_TRIPS) {
      Trip &t = trips[activeTripIndex];
      t.distance_km += delta_km;
      if (instantSpeed > t.maxSpeed) {
          t.maxSpeed = instantSpeed;
      }
      if (instantSpeed > 0.1f && (instantSpeed < t.minSpeed || t.minSpeed > 999.0f) ) { 
          t.minSpeed = instantSpeed;
      }
  }
}

/*************************************************************************
 * 6. handleStandby()
*************************************************************************/
void handleStandby() {
  static bool sleeping = false;
  if (!sleeping && (millis() - lastMovementMillis > standbyTimeout)) {
    lcd.noDisplay();
    sleeping = true;
    Serial.println(F("Intrat in standby"));
  }
  else if (sleeping && (millis() - lastMovementMillis < standbyTimeout)) { 
    lcd.display();
    sleeping = false;
    page = 255; 
    Serial.println(F("Iesit din standby"));
  }
}

/*************************************************************************
 * 7. drawNormalPages()
*************************************************************************/
void drawNormalPages(byte newPage) {
  static byte lastPageDrawn = 255; 
  static float prevAvgSpeed = -1.0f, prevRpm = -1.0f;
  static uint8_t prevHour = 255, prevMinute = 255, prevDay = 0;
  static float prevOdo = -1.0f;
  static unsigned long prevRideDays = 9999;

  if (newPage == 255 || newPage != lastPageDrawn) { 
    lcd.clear();
    lastPageDrawn = (newPage == 255) ? page : newPage; 
    prevAvgSpeed = -1.0f; prevRpm = -1.0f;
    prevHour = 255; prevMinute = 255; prevDay = 0; 
    prevOdo = -1.0f; prevRideDays = 9999;
  }

  switch(lastPageDrawn) { 
    case 0: { 
      float currentAvgSpeed = calculateAverageSpeed();
      float currentRpmVal = rpm; 

      if (abs(currentAvgSpeed - prevAvgSpeed) > 0.05 || prevAvgSpeed == -1.0f) {
        lcd.setCursor(0, 0);
        lcd.print(F("spd:")); 
        printFloatFix(currentAvgSpeed, 5, 1);
        lcd.print(F("km/h ")); 
        prevAvgSpeed = currentAvgSpeed;
      }
      if (abs(currentRpmVal - prevRpm) > 0.5 || prevRpm == -1.0f) {
        lcd.setCursor(0, 1);
        lcd.print(F("rpm:")); 
        printFloatFix(currentRpmVal, 4, 0);
        lcd.print(F("       ")); 
        prevRpm = currentRpmVal;
      }
      break;
    }
    case 1: { 
      RtcDateTime now = rtc.GetDateTime();
      if (now.Minute() != prevMinute || now.Hour() != prevHour || prevHour == 255) {
        char buf[17];
        lcd.setCursor(0, 0);
        snprintf_P(buf, sizeof(buf), PSTR("ora: %02u:%02u    "), now.Hour(), now.Minute()); 
        lcd.print(buf);
        prevHour = now.Hour();
        prevMinute = now.Minute();
      }
      if (now.Day() != prevDay || prevDay == 0) {
        char buf[17];
        lcd.setCursor(0, 1);
        snprintf_P(buf, sizeof(buf), PSTR("data:%02u/%02u/%04u"), now.Day(), now.Month(), now.Year());
        lcd.print(buf); 
        prevDay = now.Day();
      }
    } break;
    case 2: { 
      float currentOdo = odometer_km; 
      unsigned long currentRideDays = getTotalRideTimeDays();

      if (abs(currentOdo - prevOdo) > 0.05 || prevOdo == -1.0f) {
        lcd.setCursor(0, 0);
        lcd.print(F("odo:")); printFloatFix(currentOdo, 7, 1); lcd.print(F("km  ")); 
        prevOdo = currentOdo;
      }
      if (currentRideDays != prevRideDays || prevRideDays == 9999) {
        lcd.setCursor(0, 1);
        lcd.print(F("timp:")); lcd.print(currentRideDays); lcd.print(F("zile   ")); 
        prevRideDays = currentRideDays;
      }
      break;
    }
    case 3: {  
      lcd.setCursor(0,0);
      lcd.print(F(">Setari     OK")); 
      lcd.setCursor(0,1);
      lcd.print(F("U/D Nav, OK Sel")); 
    } break;
  }
}

/*************************************************************************
 * 8. runSettingsMenu()
*************************************************************************/
void runSettingsMenu() {
  byte subMenuIndex = 0;
  bool up, down, mode, ok;
  byte lastSubMenuDrawn = 255; 
  bool exitMenu = false;

  while (!exitMenu) {
    if (subMenuIndex != lastSubMenuDrawn) {
      lcd.clear();
      lcd.setCursor(0,0);
      switch (subMenuIndex) {
        case 0: lcd.print(F("Diam. rotii")); break;
        case 1: lcd.print(F("Seteaza ora")); break;
        case 2: lcd.print(F("Seteaza data")); break;
        case 3: lcd.print(F("RESET TOTAL")); break;
        case 4: lcd.print(F("Export TureCSV")); break; 
      }
      lcd.setCursor(0, 1);
      lcd.print(F("U/D Nav OK M-Exit")); 
      lastSubMenuDrawn = subMenuIndex;
    }

    bool buttonPressed = false;
    do {
      buttonPressed = readButtons(up, down, mode, ok);
    } while (!buttonPressed && !exitMenu); 

    if (ok) {
      if      (subMenuIndex == 0) setWheelDiameter();
      else if (subMenuIndex == 1) setClockTime();
      else if (subMenuIndex == 2) setClockDate();
      else if (subMenuIndex == 3) factoryReset(); 
      else if (subMenuIndex == 4) exportTripsToSerial(false); // <<--- MODIFICAT: Apel cu 'false'
      lastSubMenuDrawn = 255; 
    } else if (up) {
      subMenuIndex = (subMenuIndex == 0) ? 4 : subMenuIndex - 1; 
    } else if (down) {
      subMenuIndex = (subMenuIndex + 1) % 5; 
    } else if (mode) {
      exitMenu = true; 
    }
  }
  page = 0; 
}

/*************************************************************************
 * 9. confirmStartTrip()  & startStopTrip()
*************************************************************************/
void startStopTrip(bool start) {
  if (start) {
    if (tripRunning) return; 

    tripRunning = true;
    activeTripIndex = (activeTripIndex + 1) % MAX_TRIPS; 

    Trip &t = trips[activeTripIndex];
    t = {}; 
    t.minSpeed = 999.9f;      
    t.maxSpeed = 0.0f;           
    t.stamp = rtc.GetDateTime();
    t.tripStartTimeMillis = millis(); 
  } else {
    if (!tripRunning || activeTripIndex >= MAX_TRIPS) return; 

    tripRunning = false;
    Trip &t = trips[activeTripIndex];
    t.duration_s = (millis() - t.tripStartTimeMillis) / 1000UL; 

    if (t.duration_s > 0 && t.distance_km > 0.001f) { // Ensure some distance for meaningful avg speed
      t.avgSpeed = (t.distance_km / (float)t.duration_s) * 3600.0f;
    } else {
      t.avgSpeed = 0.0f;
    }
    if (t.minSpeed > 999.0f) t.minSpeed = 0.0f; // If minSpeed was never updated, set to 0
    if (t.distance_km < 0.001f) { // If no significant distance, speeds are likely 0
        t.maxSpeed = 0.0f;
        t.minSpeed = 0.0f;
    }
    
    saveTripToEEPROM(activeTripIndex); 
  }
}

bool confirmStartTrip() {
  lcd.clear(); lcd.print(F("Pornesc tura?"));
  lcd.setCursor(0,1); lcd.print(F("DA(A2) NU(A0)"));
  bool up,down,mode_btn,ok_btn; 
  while(true){
    if (readButtons(up,down,mode_btn,ok_btn)) { 
        if(up){ 
          startStopTrip(true);
          lcd.clear(); lcd.print(F("Tura START!"));
          delay(1000);
          return true;
        }
        if(down){ 
          lcd.clear(); lcd.print(F("Anulat"));
          delay(700);
          return false;
        }
    }
  }
}

/*************************************************************************
 * 10. confirmStartLock()
*************************************************************************/
bool confirmStartLock() {
  lcd.clear(); lcd.print(F("Blochez bicla?"));
  lcd.setCursor(0,1); lcd.print(F("DA(A2) NU(A0)"));
  bool up,down,mode_btn,ok_btn; 

  while(true){
    if(readButtons(up,down,mode_btn,ok_btn)){ 
        if(up) break; 
        if(down) return false; 
    }
  }

  lcd.clear(); lcd.print(F("PIN:    (A0-A3)")); 
  pinIndex=0;
  byte displayPinCursor = 5; 

  for(byte i=0; i<4; ++i) lockPin[i] = 0;

  while(pinIndex < 4){
    bool btn_up_local, btn_down_local, btn_mode_local, btn_ok_local;
    if(readButtons(btn_up_local, btn_down_local, btn_mode_local, btn_ok_local)){
        BtnCode b = (BtnCode)255; 
        if(btn_down_local) b = CODE_DN;  
        else if(btn_mode_local) b = CODE_MD; 
        else if(btn_up_local) b = CODE_UP;   
        else if(btn_ok_local) b = CODE_OK;   

        if(b != 255) { 
            lockPin[pinIndex] = b;
            lcd.setCursor(displayPinCursor + pinIndex, 0); lcd.print('*');
            pinIndex++;
            tone(BUZZER_PIN, 3000, 50); 
        }
    }
  }
  pinIndex = 0; 
  lockArmed = true; alarmActive = false; attemptsLeft = 3;
  lockArmedTime = millis(); 
  lcd.clear(); lcd.print(F("BLOCAT!"));
  delay(800);
  return true;
}

/*************************************************************************
 * 11. lockModeRunner()
*************************************************************************/
void lockModeRunner(bool up,bool down,bool mode_btn_val,bool ok, bool wasButtonPressed) {
  static bool redrawScreen = true; 
  static byte currentPinDisplayIndex = 0;

  if(alarmActive) {
    if (millis() % 1000 < 500) { 
        tone(BUZZER_PIN, 2000, 450); 
    } else {
        noTone(BUZZER_PIN); 
    }
  } else {
    noTone(BUZZER_PIN); 
  }

  if(redrawScreen){
    lcd.clear();
    lcd.print(lockArmed ? F("BLOCAT") : F("DEBLOCARE..."));
    lcd.setCursor(0,1);
    if(!lockArmed) { 
        lcd.print(F("-> Mod Normal   ")); 
    } else { 
        lcd.print(F("PIN: ")); 
        for (byte i = 0; i < currentPinDisplayIndex; ++i) { 
            lcd.print('*');
        }
        for (byte i = currentPinDisplayIndex; i < 4; ++i) { 
            lcd.print(' ');
        }
    }
    redrawScreen = false;
  }

  if(!lockArmed){ 
    noTone(BUZZER_PIN);
    currentMode=MODE_NORMAL;
    page=0; 
    redrawScreen = true; 
    currentPinDisplayIndex = 0; 
    pinIndex = 0;
    return;
  }

  if (wasButtonPressed && !alarmActive) { 
      BtnCode b = (BtnCode)255;
      if(down) b = CODE_DN;         
      else if(mode_btn_val) b = CODE_MD; 
      else if(up) b = CODE_UP;           
      else if(ok) b = CODE_OK;           

      if(b != 255 && pinIndex < 4) { 
        lcd.setCursor(5 + pinIndex, 1); lcd.print('*'); 
        currentPinDisplayIndex = pinIndex + 1;
        tone(BUZZER_PIN, 3000, 50); 

        if(b == lockPin[pinIndex]){ 
          pinIndex++;
          if(pinIndex == 4){ 
            lockArmed = false; alarmActive = false; noTone(BUZZER_PIN);
            lcd.clear(); lcd.print(F("Deblocat!"));
            delay(1000);
            redrawScreen = true; 
          }
        } else { 
          pinIndex = 0; currentPinDisplayIndex = 0; 
          attemptsLeft--;
          lcd.clear();
          if(attemptsLeft > 0){
            lcd.print(F("GRESIT! Ramas:"));
            lcd.setCursor(0,1); lcd.print(attemptsLeft); lcd.print(F(" incercari"));
            tone(BUZZER_PIN, 500, 300); delay(300); tone(BUZZER_PIN, 500, 300);
          } else {
            lcd.print(F("!!! ALARMA !!!"));
            lcd.setCursor(0,1); lcd.print(F("Sistem blocat.")); 
            alarmActive = true; 
          }
          delay(1500); 
          redrawScreen = true; 
        }
      }
  } else if (lockArmed && alarmActive) {
      if (redrawScreen) { 
          lcd.clear();
          lcd.print(F("!!! ALARMA !!!"));
          lcd.setCursor(0,1); lcd.print(F("Sistem blocat."));
          redrawScreen = false;
      }
  }
}
/*************************************************************************
 * 12. tripModeRunner()
*************************************************************************/
void tripModeRunner(bool up, bool down, bool ok_btn, bool newButtonPress) {
  static byte tripPageDisplay = 0; 
  static byte lastTripPageDrawn = 255;

  if (activeTripIndex >= MAX_TRIPS) return; 
  Trip &t = trips[activeTripIndex]; 

  static float lastAvgSpeedTrip = -1.0f, lastRpmTrip = -1.0f;
  static float lastDistanceTrip = -1.0f, lastMaxSpeedTrip = -1.0f, lastMinSpeedTrip = -1.0f;
  static unsigned long lastDurationSecsTrip = 999999; 
  static RtcDateTime lastClockTimeTrip;


  if (tripRunning) {
      t.duration_s = (millis() - t.tripStartTimeMillis) / 1000UL;
  }

  bool pageChangeRequest = false;
  if (newButtonPress) {
    if (up)   { tripPageDisplay = (tripPageDisplay == 0) ? 3 : tripPageDisplay - 1; pageChangeRequest = true; }
    if (down) { tripPageDisplay = (tripPageDisplay + 1) % 4; pageChangeRequest = true; }
  }

  if (pageChangeRequest || tripPageDisplay != lastTripPageDrawn) {
    lcd.clear();
    lastTripPageDrawn = tripPageDisplay;
    lastAvgSpeedTrip = -1.0f; lastRpmTrip = -1.0f;
    lastDistanceTrip = -1.0f; lastDurationSecsTrip = 999999;
    lastMaxSpeedTrip = -1.0f; lastMinSpeedTrip = -1.0f;
    lastClockTimeTrip = RtcDateTime(0); 
  }

  float currentAvgSpeedVal = calculateAverageSpeed();
  float currentRpmValTrip = rpm; 
  float currentDistanceVal = t.distance_km;
  unsigned long currentDurationSecsVal = t.duration_s;

  switch (tripPageDisplay) {
    case 0: 
      if (abs(currentAvgSpeedVal - lastAvgSpeedTrip) > 0.05f || lastAvgSpeedTrip == -1.0f) {
        lcd.setCursor(0, 0);
        lcd.print(F("spd:")); printFloatFix(currentAvgSpeedVal, 5, 1); lcd.print(F("km/h "));
        lastAvgSpeedTrip = currentAvgSpeedVal;
      }
      if (abs(currentRpmValTrip - lastRpmTrip) > 0.5f || lastRpmTrip == -1.0f) {
        lcd.setCursor(0, 1);
        lcd.print(F("rpm:")); printFloatFix(currentRpmValTrip, 4, 0); lcd.print(F("       "));
        lastRpmTrip = currentRpmValTrip;
      }
      break;

    case 1: 
      if (abs(currentDistanceVal - lastDistanceTrip) > 0.01f || lastDistanceTrip == -1.0f) { 
        lcd.setCursor(0, 0);
        lcd.print(F("Dist:")); printFloatFix(currentDistanceVal, 6, 2); lcd.print(F("km "));
        lastDistanceTrip = currentDistanceVal;
      }
      if (currentDurationSecsVal != lastDurationSecsTrip || lastDurationSecsTrip == 999999) {
        lcd.setCursor(0, 1);
        unsigned int hours = currentDurationSecsVal / 3600;
        unsigned int minutes = (currentDurationSecsVal % 3600) / 60;
        unsigned int seconds = currentDurationSecsVal % 60;
        char timeBuf[10]; 
        if (hours > 0) snprintf_P(timeBuf, sizeof(timeBuf), PSTR("%u:%02u:%02u"), hours, minutes, seconds);
        else snprintf_P(timeBuf, sizeof(timeBuf), PSTR("%02u:%02u"), minutes, seconds);
        
        lcd.print(F("Timp:")); lcd.print(timeBuf); lcd.print(F("   ")); 
        lastDurationSecsTrip = currentDurationSecsVal;
      }
      break;

    case 2: { 
        float currentMaxSpeed = t.maxSpeed;
        float currentMinSpeed = (t.minSpeed > 999.0f && t.distance_km < 0.001f) ? 0.0f : t.minSpeed; 
        
        if(abs(currentMaxSpeed - lastMaxSpeedTrip) > 0.05f || lastMaxSpeedTrip == -1.0f){
            lcd.setCursor(0,0);
            lcd.print(F("MaxSp:")); printFloatFix(currentMaxSpeed, 5, 1); lcd.print(F("km/h"));
            lastMaxSpeedTrip = currentMaxSpeed;
        }
        if(abs(currentMinSpeed - lastMinSpeedTrip) > 0.05f || lastMinSpeedTrip == -1.0f){
            lcd.setCursor(0,1);
            lcd.print(F("MinSp:")); printFloatFix(currentMinSpeed, 5, 1); lcd.print(F("km/h"));
            lastMinSpeedTrip = currentMinSpeed;
        }
    } break;
    
    case 3: { 
      RtcDateTime now = rtc.GetDateTime();
      if (now.Minute() != lastClockTimeTrip.Minute() || now.Hour() != lastClockTimeTrip.Hour() || lastClockTimeTrip.Year()==0) {
        char buf[17];
        lcd.setCursor(0, 0);
        snprintf_P(buf, sizeof(buf), PSTR("Ora: %02u:%02u:%02u  "), now.Hour(), now.Minute(), now.Second());
        lcd.print(buf);
      }
      if (now.Day() != lastClockTimeTrip.Day() || lastClockTimeTrip.Year()==0) {
         char buf[17];
        lcd.setCursor(0, 1);
        snprintf_P(buf, sizeof(buf), PSTR("Data:%02u/%02u/%02u "), now.Day(), now.Month(), now.Year()%100); 
        lcd.print(buf);
      }
      if(lastClockTimeTrip.Year()==0 || now.Minute() != lastClockTimeTrip.Minute()) lastClockTimeTrip = now; 
    } break;
  }

  if (ok_btn && newButtonPress) { 
    if (tripRunning) {
        lcd.clear(); lcd.print(F("Opreste tura?"));
        lcd.setCursor(0, 1); lcd.print(F("DA(A2) NU(A0)"));
        bool up2, down2, mode2, ok2;
        while (true) {
          if (readButtons(up2, down2, mode2, ok2)) {
            if (up2) { 
                startStopTrip(false); 
                currentMode = MODE_NORMAL; 
                page = 0; 
                lcd.clear(); lcd.print(F("Tura salvata!"));
                delay(1000);
                lastTripPageDrawn = 255; 
                return; 
            }
            if (down2) { 
                lastTripPageDrawn = 255; 
                return; 
            }
          }
        }
    } else { 
        currentMode = MODE_NORMAL;
        page = 0;
        lastTripPageDrawn = 255;
        return;
    }
  }
}

/*************************************************************************
 * 13. loop()
*************************************************************************/
void loop() {
  static Mode pendingMode = MODE_NORMAL;
  static bool selectingMode = false;
  static Mode lastShownModeInSelection = MODE_NORMAL;
  static bool firstDrawSelect = true;
  static unsigned long lastActiveTimeUpdate = 0;

  unsigned long currentTime = millis();

  // --- Procesare comenzi de la PC ---
  if (Serial.available() > 0) {
    String command = Serial.readStringUntil('\n'); 
    command.trim(); 
    
    if (command.equals(CMD_EXPORT_TRIPS_NOW_STR)) { 
        Serial.println(F("INFO: Comanda de export primita de la PC."));
        exportTripsToSerial(true); 
    } else {
        Serial.print(F("INFO: Comanda necunoscuta primita: "));
        Serial.println(command);
    }
  }

  if (newPulseDetected) {
    noInterrupts();
    newPulseDetected = false; 
    interrupts();

    lastMovementMillis = currentTime; 
    dataChangedSinceLastSave = true;

    unsigned long currentPulseTimeMicros;
    noInterrupts();
    currentPulseTimeMicros = lastPulseMicros; 
    interrupts();

    static unsigned long previousPulseMicrosForCalc = 0;
    unsigned long dT_micros = currentPulseTimeMicros - previousPulseMicrosForCalc;

    if (previousPulseMicrosForCalc > 0 && dT_micros > 5000) { // Min time diff 5ms (prevents div by zero or extreme RPM)
      // MODIFICARE 1: Calcul corect instantSpeed și rpm
      instantSpeed = (wheelCircum_mm * 3600.0) / dT_micros; // km/h
      rpm = 60000000.0 / dT_micros;                         // Revolutions per minute
    } else if (previousPulseMicrosForCalc == 0) { 
      // First pulse, speed/rpm can't be calculated yet from dT. They remain at their previous value (likely 0).
    }
    // For very small dT_micros (<=5000), speed and rpm are not updated to avoid erroneously high values.
    // They retain their last valid calculated value.
    
    previousPulseMicrosForCalc = currentPulseTimeMicros;

    rollingSpeedBuffer[rollingIdx] = instantSpeed;
    rollingIdx = (rollingIdx + 1) % 10;

    updateOdoAndTripData(); 
  }

  // MODIFICARE 2: Mărit timeout-ul pentru resetarea vitezei la 0
  if (currentTime - lastMovementMillis > 3000 && (instantSpeed > 0.05 || rpm > 0.05)) { 
    instantSpeed = 0;
    rpm = 0;
    for(byte i=0; i<10; ++i) rollingSpeedBuffer[i] = 0; // Clear rolling buffer as well
    rollingIdx = 0;
    dataChangedSinceLastSave = true; 
  }

  if (instantSpeed > 0.1f) { 
    if (lastActiveTimeUpdate > 0 && currentTime > lastActiveTimeUpdate) { 
        totalActiveRideMillis += (currentTime - lastActiveTimeUpdate);
    }
    lastActiveTimeUpdate = currentTime;
    dataChangedSinceLastSave = true;
  } else {
      lastActiveTimeUpdate = 0; 
  }

  handleStandby();

  bool up_btn = false, down_btn = false, mode_btn_press = false, ok_btn = false;
  bool newButtonPress = readButtons(up_btn, down_btn, mode_btn_press, ok_btn);

  if (currentMode == MODE_LOCK && lockArmed && !alarmActive) {
    if (currentTime - lockArmedTime > lockGracePeriodMillis) {
        if (lastMovementMillis > (lockArmedTime + lockGracePeriodMillis)) {
            alarmActive = true;
        }
    }
  }

  if (currentMode == MODE_NORMAL && !selectingMode && mode_btn_press && newButtonPress) {
      selectingMode = true;
      pendingMode = MODE_NORMAL; 
      firstDrawSelect = true;
      lastShownModeInSelection = MODE_NORMAL; 
  }

  if (selectingMode) {
    if (mode_btn_press && newButtonPress) { 
      pendingMode = static_cast<Mode>((pendingMode + 1) % 3); 
      firstDrawSelect = true;
    }

    if (firstDrawSelect || pendingMode != lastShownModeInSelection) {
      lcd.clear();
      lcd.print(F("Mod?: "));
      lcd.setCursor(6,0);
      switch(pendingMode) {
          case MODE_NORMAL: lcd.print(F("NORMAL  ")); break;
          case MODE_TRIP:   lcd.print(F("TURA    ")); break;
          case MODE_LOCK:   lcd.print(F("BLOCARE ")); break;
      }
      lcd.setCursor(0, 1);
      lcd.print(F("OK Sel, Mod Next"));
      lastShownModeInSelection = pendingMode;
      firstDrawSelect = false;
    }

    if (ok_btn && newButtonPress) {
      bool selectionSuccessful = true;
      if (pendingMode == MODE_TRIP) {
        if (tripRunning) {
           selectionSuccessful = true; 
        } else if (!confirmStartTrip()) {
          selectionSuccessful = false;
        }
      } else if (pendingMode == MODE_LOCK) {
        if (!confirmStartLock()) {
          selectionSuccessful = false;
        }
      }

      if (selectionSuccessful) {
          currentMode = pendingMode;
      }
      selectingMode = false;
      page = 0; 
      if (currentMode == MODE_NORMAL) drawNormalPages(255); 
    }
    return; 
  }


  switch(currentMode){
    case MODE_NORMAL:
      if(ok_btn && page == 3 && newButtonPress) {
          runSettingsMenu();
          page = 0; 
          drawNormalPages(255); 
      } else if (newButtonPress) { 
          if(up_btn)   page = (page == 0) ? 3 : page - 1; 
          if(down_btn) page = (page + 1) % 4;
      }
      drawNormalPages(page);
      break;

    case MODE_TRIP:
      tripModeRunner(up_btn, down_btn, ok_btn, newButtonPress);
      break;

    case MODE_LOCK:
      lockModeRunner(up_btn, down_btn, mode_btn_press, ok_btn, newButtonPress);
      break;
  }

  bool shouldSave = false;
  if (dataChangedSinceLastSave) {
    if (instantSpeed < 0.05f && currentTime - lastMovementMillis > eepromSaveIntervalStopped) {
      shouldSave = true;
    } 
    else if (instantSpeed > 0.1f && currentTime - lastEepromSaveMillis > eepromSaveIntervalMoving) {
      shouldSave = true;
    }
  }

  if (shouldSave) {
    saveOdometerDataToEEPROM();
    dataChangedSinceLastSave = false;
    lastEepromSaveMillis = currentTime;
    Serial.println(F("Date odometru salvate in EEPROM."));
  }
}

/*************************************************************************
 * 14.  SETĂRI ȘI RESET
*************************************************************************/
void setWheelDiameter() {
  float d_edit = wheelDiameterIn; 
  float lastDrawnD = -1.0f;    
  bool up, down, mode_btn, ok_btn;

  lcd.clear();
  lcd.print(F("Diametru roata:")); 

  while (true) {
    if (abs(d_edit - lastDrawnD) > 0.01f || lastDrawnD == -1.0f) { 
      lcd.setCursor(0, 1);
      printFloatFix(d_edit, 4, 1); 
      lcd.print(F("\" U/D OK=S M=X")); 
      lastDrawnD = d_edit;
    }

    bool buttonPressed = false;
    do {
        buttonPressed = readButtons(up, down, mode_btn, ok_btn);
    } while (!buttonPressed);

    if      (up)   { d_edit = min(39.0f, d_edit + 0.5f); }
    else if (down) { d_edit = max(10.0f, d_edit - 0.5f); } 
    else if (ok_btn) { 
      wheelDiameterIn = d_edit;
      wheelCircum_mm = d_edit * 25.4 * M_PI;
      saveSettingsToEEPROM();
      lcd.clear(); lcd.print(F("Salvat!")); delay(700);
      return;
    } else if (mode_btn) { 
      return;
    }
  }
}

void setClockTime() {
  RtcDateTime dt_edit = rtc.GetDateTime(); 
  byte h = dt_edit.Hour(), m = dt_edit.Minute();
  byte cursor_pos = 0; 

  byte lastH_drawn = 255, lastM_drawn = 255, lastCursor_drawn = 255;
  bool up, down, mode_btn, ok_btn;

  lcd.clear();
  lcd.print(F("Seteaza Ora:")); 

  while (true) {
    if (h != lastH_drawn || m != lastM_drawn || cursor_pos != lastCursor_drawn || lastH_drawn == 255) {
      lcd.setCursor(0, 1);
      char buf[17];
      snprintf_P(buf, sizeof(buf), PSTR("%c%02u:%c%02u   OK M"), 
               (cursor_pos == 0 ? '>' : ' '), h,
               (cursor_pos == 1 ? '>' : ' '), m);
      lcd.print(buf);
      lastH_drawn = h; lastM_drawn = m; lastCursor_drawn = cursor_pos;
    }

    bool buttonPressed = false;
    do {
        buttonPressed = readButtons(up,down,mode_btn,ok_btn);
    } while (!buttonPressed);

    if      (up)   { if (cursor_pos == 0) h = (h + 1) % 24; else m = (m + 1) % 60; }
    else if (down) { if (cursor_pos == 0) h = (h + 23) % 24; else m = (m + 59) % 60; }
    else if (mode_btn) { cursor_pos = (cursor_pos + 1) % 2; } 
    else if (ok_btn) { 
      if (rtc.GetIsWriteProtected()) rtc.SetIsWriteProtected(false);
      rtc.SetDateTime(RtcDateTime(dt_edit.Year(), dt_edit.Month(), dt_edit.Day(), h, m, 0)); 
      if (!rtc.GetIsWriteProtected()) rtc.SetIsWriteProtected(true);
      lcd.clear(); lcd.print(F("Ora salvata!")); delay(700);
      return;
    }
  }
}

void setClockDate() {
  RtcDateTime dt_edit = rtc.GetDateTime();
  uint16_t y_edit = dt_edit.Year();
  byte mo_edit = dt_edit.Month(), d_edit = dt_edit.Day();
  byte cursor_pos = 0; 

  uint16_t lastY_drawn = 0; byte lastMo_drawn = 0, lastD_drawn = 0, lastCursor_drawn = 255;
  bool up, down, mode_btn, ok_btn;

  auto daysInMonth = [](byte month_val, uint16_t year_val) {
    if (month_val < 1 || month_val > 12) month_val = 1; 
    const byte month_days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    byte num_days = month_days[month_val - 1];
    if (month_val == 2 && RtcDateTime::IsLeapYear(year_val)) { 
      num_days = 29; 
    }
    return num_days;
  };

  lcd.clear();
  lcd.print(F("Seteaza Data:")); 

  while (true) {
    byte max_days_current = daysInMonth(mo_edit, y_edit);
    if (d_edit > max_days_current) d_edit = max_days_current;


    if (d_edit != lastD_drawn || mo_edit != lastMo_drawn || y_edit != lastY_drawn || cursor_pos != lastCursor_drawn || lastD_drawn == 0) {
      lcd.setCursor(0, 1);
      char buf[17];
      snprintf_P(buf, sizeof(buf), PSTR("%c%02u/%c%02u/%c%04u OKM"), 
               (cursor_pos == 0 ? '>' : ' '), d_edit,
               (cursor_pos == 1 ? '>' : ' '), mo_edit,
               (cursor_pos == 2 ? '>' : ' '), y_edit);
      lcd.print(buf);
      lastD_drawn = d_edit; lastMo_drawn = mo_edit; lastY_drawn = y_edit; lastCursor_drawn = cursor_pos;
    }
    
    bool buttonPressed = false;
    do {
        buttonPressed = readButtons(up,down,mode_btn,ok_btn);
    } while (!buttonPressed);

    byte max_days = daysInMonth(mo_edit, y_edit); 
    if (up) {
      if      (cursor_pos == 0) { d_edit = (d_edit % max_days) + 1; }
      else if (cursor_pos == 1) { mo_edit = (mo_edit % 12) + 1; }
      else                      { y_edit = min((uint16_t)2099, (uint16_t)(y_edit + 1)); }
    } else if (down) {
      if      (cursor_pos == 0) { d_edit = (d_edit == 1 ? max_days : d_edit - 1); }
      else if (cursor_pos == 1) { mo_edit = (mo_edit == 1 ? 12 : mo_edit - 1); }
      else                      { y_edit = max((uint16_t)2023, (uint16_t)(y_edit - 1)); }
    } else if (mode_btn) {
      cursor_pos = (cursor_pos + 1) % 3;
    } else if (ok_btn) { 
      if (rtc.GetIsWriteProtected()) rtc.SetIsWriteProtected(false);
      rtc.SetDateTime(RtcDateTime(y_edit, mo_edit, d_edit, dt_edit.Hour(), dt_edit.Minute(), dt_edit.Second()));
      if (!rtc.GetIsWriteProtected()) rtc.SetIsWriteProtected(true);
      lcd.clear(); lcd.print(F("Data salvata!")); delay(700);
      return;
    }
  }
}

void factoryReset() {
  lcd.clear();
  lcd.print(F("Sigur RESET?"));
  lcd.setCursor(0,1);
  lcd.print(F("DA(OK) NU(Mod)"));

  bool up_b, down_b, mode_b, ok_b; 
  while(true) {
    if(readButtons(up_b, down_b, mode_b, ok_b)) {
        if (ok_b) break; 
        if (mode_b) { 
            return;
        }
    }
  }

  lcd.clear(); lcd.print(F("RESET IN CURS..."));

  EEPROM.put(EEPROM_ADDR_MAGIC_NUM, (uint16_t)0xFFFF); // Invalidate magic number temporarily

  pulseCount = 0; 
  odometer_km = 0.0f;
  totalActiveRideMillis = 0;
  activeTripIndex = 0; 
  wheelDiameterIn = 26.0f; // Default wheel diameter
  
  EEPROM.put(EEPROM_ADDR_MAGIC_NUM, EEPROM_MAGIC_VALUE);
  EEPROM.put(EEPROM_ADDR_WHEEL_DIAM, wheelDiameterIn);
  EEPROM.put(EEPROM_ADDR_ODOMETER, odometer_km);
  EEPROM.put(EEPROM_ADDR_TOTAL_RIDE_MS, totalActiveRideMillis);
  EEPROM.put(EEPROM_ADDR_ACTIVE_TRIP_IDX, activeTripIndex);

  wheelCircum_mm = wheelDiameterIn * 25.4 * M_PI; 

  for(int i=0; i < MAX_TRIPS; ++i) {
    trips[i] = {}; // Clear trip data
    EEPROM.put(EEPROM_ADDR_TRIPS_START + i * sizeof(Trip), trips[i]); 
  }
  
  if (rtc.GetIsWriteProtected()) rtc.SetIsWriteProtected(false);
  rtc.SetDateTime(RtcDateTime(__DATE__, __TIME__)); // Reset RTC to compile time
  if (!rtc.GetIsWriteProtected()) rtc.SetIsWriteProtected(true);

  lockArmed = false; alarmActive = false;
  tripRunning = false;
  currentMode = MODE_NORMAL; page = 0;
  
  lcd.clear(); lcd.print(F("RESET EFECTUAT!"));
  delay(1500);
}

/*************************************************************************
 * 15.  FUNCȚII EEPROM și ACCESORI
*************************************************************************/
void loadFromEEPROM() {
  uint16_t magic;
  EEPROM.get(EEPROM_ADDR_MAGIC_NUM, magic);

  if (magic == EEPROM_MAGIC_VALUE) { 
    Serial.println(F("EEPROM magic number OK. Loading data."));
    EEPROM.get(EEPROM_ADDR_WHEEL_DIAM, wheelDiameterIn);
    if (isnan(wheelDiameterIn) || wheelDiameterIn < 10.0f || wheelDiameterIn > 39.0f) { 
        wheelDiameterIn = 26.0f; // Default if EEPROM data is corrupted
    }
    EEPROM.get(EEPROM_ADDR_ODOMETER, odometer_km);
    if (isnan(odometer_km) || odometer_km < 0) odometer_km = 0.0f;

    EEPROM.get(EEPROM_ADDR_TOTAL_RIDE_MS, totalActiveRideMillis);
    
    EEPROM.get(EEPROM_ADDR_ACTIVE_TRIP_IDX, activeTripIndex);
    if (activeTripIndex >= MAX_TRIPS) activeTripIndex = 0;

    for (byte i = 0; i < MAX_TRIPS; ++i) {
      EEPROM.get(EEPROM_ADDR_TRIPS_START + i * sizeof(Trip), trips[i]);
      // Basic validation for loaded trip data can be added here if needed
    }
  } else { 
    Serial.println(F("EEPROM magic number NOT OK or first run. Initializing."));
    wheelDiameterIn = 26.0f;
    odometer_km = 0.0f;
    totalActiveRideMillis = 0;
    activeTripIndex = 0; 

    EEPROM.put(EEPROM_ADDR_MAGIC_NUM, EEPROM_MAGIC_VALUE);
    saveSettingsToEEPROM(); 
    saveOdometerDataToEEPROM(); 
    EEPROM.put(EEPROM_ADDR_ACTIVE_TRIP_IDX, activeTripIndex);

    for (byte i = 0; i < MAX_TRIPS; ++i) {
      trips[i] = {}; 
      EEPROM.put(EEPROM_ADDR_TRIPS_START + i * sizeof(Trip), trips[i]);
    }
  }
}

void saveSettingsToEEPROM() {
  EEPROM.put(EEPROM_ADDR_WHEEL_DIAM, wheelDiameterIn);
  Serial.println(F("Settings saved to EEPROM."));
}

void saveOdometerDataToEEPROM() {
  EEPROM.put(EEPROM_ADDR_ODOMETER, odometer_km);
  EEPROM.put(EEPROM_ADDR_TOTAL_RIDE_MS, totalActiveRideMillis);
  Serial.println(F("Odometer data saved to EEPROM."));
}

void saveTripToEEPROM(byte tripIdx) {
  if (tripIdx < MAX_TRIPS) {
    EEPROM.put(EEPROM_ADDR_TRIPS_START + tripIdx * sizeof(Trip), trips[tripIdx]);
    EEPROM.put(EEPROM_ADDR_ACTIVE_TRIP_IDX, activeTripIndex); 
    Serial.print(F("Trip ")); Serial.print(tripIdx); Serial.println(F(" saved to EEPROM."));
  }
}

unsigned long getTotalRideTimeDays() {
    if (totalActiveRideMillis == 0) return 0;
    return totalActiveRideMillis / (1000UL * 60UL * 60UL * 24UL); 
}

/*************************************************************************
   FUNCTIE EXPORT TURE PRIN SERIAL (CSV)
**************************************************************************/
void exportTripsToSerial(bool triggeredByPC /*= false*/) { 
  if (!triggeredByPC) { 
    lcd.clear();
    lcd.print(F("Export Ture..."));
    lcd.setCursor(0,1);
    lcd.print(F("Vezi Serial Mon."));
  }

  Serial.println(F("--- EXPORT DATE TURE (CSV) ---"));
  Serial.println(F("ID_Tura,VitezaMedie,VitezaMax,VitezaMin,Distanta_km,Durata_s,An,Luna,Zi,Ora,Minut,Secunda"));

  Trip tempTrip; 
  for (byte i = 0; i < MAX_TRIPS; ++i) {
    EEPROM.get(EEPROM_ADDR_TRIPS_START + i * sizeof(Trip), tempTrip);

    // Only export trips that have some data (valid year, distance, or duration)
    if (tempTrip.stamp.Year() >= 2023 || tempTrip.distance_km > 0.001f || tempTrip.duration_s > 0) {
      Serial.print(i);
      Serial.print(F(","));
      Serial.print(tempTrip.avgSpeed, 2); 
      Serial.print(F(","));
      Serial.print(tempTrip.maxSpeed, 2);
      Serial.print(F(","));
      Serial.print(tempTrip.minSpeed, 2);
      Serial.print(F(","));
      Serial.print(tempTrip.distance_km, 3); 
      Serial.print(F(","));
      Serial.print(tempTrip.duration_s);
      Serial.print(F(","));
      Serial.print(tempTrip.stamp.Year());
      Serial.print(F(","));
      Serial.print(tempTrip.stamp.Month());
      Serial.print(F(","));
      Serial.print(tempTrip.stamp.Day());
      Serial.print(F(","));
      Serial.print(tempTrip.stamp.Hour());
      Serial.print(F(","));
      Serial.print(tempTrip.stamp.Minute());
      Serial.print(F(","));
      Serial.println(tempTrip.stamp.Second());
    }
  }
  Serial.println(F("--- SFARSIT EXPORT ---"));

  if (!triggeredByPC) {
    delay(2000); // Give time to see message on LCD if not triggered by PC
  }
}